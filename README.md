### **¿Qué es un patrón de diseño?**
Es una solución general irrepetible para un problema que aparece regularmente.

**Utilizar patrones de diseño** ayuda a evitar problemas sutiles que a veces pasan inadvertidos y pueden llegar a causar problemas importantes. Además, mejora la legibilidad del código.

**La arquitectura de software** nos permite tomar a tiempo las decisiones críticas sobre la arquitectura de un programa que pueden afectar, de manera permanente, la dirección del proyecto.

**Los patrones se aplican tanto al desarrollo como a la arquitectura general** de una aplicación, y con ellos podríamos prevenir los errores en un proyecto antes de que ocurran y acelerar el proceso de desarrollo.

La **toma de requerimientos** proporciona información fundamental para delinear el proyecto por el resto de su vida útil.

### Patrones de diseño
* **Arquitectura monolítica**: Una arquitectura monolítica se refiere al clásico diseño unificado de un software, donde todo está acoplado o unido como un solo elemento. De allí su nombre inspirado en los monolitos, que son enormes masas como montañas formadas por un solo bloque rocoso. El software monolítico está diseñado para ser autocontenido. Todos sus componentes están interconectados y son interdependientes entre sí. En esta arquitectura fuertemente acoplada, cada componente y sus elementos asociados tienen que estar presentes para que el código se ejecute o compile efectivamente. Esto significa que, si por el contrario alguna parte o dependencia no está presente, este tipo de software no puede funcionar. En un programa que usa esta arquitectura, cuando llegue el momento de actualizar o reparar algún componente, es de necesario reescribir toda la aplicación o al menos grandes porciones de ella porque todo está acoplado tan fuertemente que, si algo falla o se remplaza, se genera una caída en dominó de todas sus partes. Por esta razón, es particularmente costoso desarrollar y mantener un software con arquitectura monolítica, y es común que, una vez terminado el programa, permanezca prácticamente igual durante toda su vida útil, la que, a su vez, se ve fuertemente reducida porque el programa se va a desactualizar mucho más rápido de lo normal. Finalmente, otro problema importante es que, al tener la funcionalidad en un solo lugar, quedamos con una aplicación muy frágil donde el más mínimo error en el código puede comprometer la operación completa, y es muy fácil crear fallos críticos del sistema. Para este punto, estarás pensando: «¿Quién en su sano juicio implementa una arquitectura monolítica en su software?». Y la respuesta puede ser más frustrante de lo que esperas, porque es más común de lo que puedas imaginar. Este tipo de programas en muchísimos casos tiene una aparición espontánea. O sea, no siempre se debe a que fueron diseñados para ser así, sino que comenzar una pequeña pieza de software que comenzó a crecer sin ninguna planificación y, eventualmente, terminó como un gigantesco monolito donde todo ocurre en el mismo lugar. Es común que ningún arquitecto esté involucrado o que el o los desarrolladores que lo crean tengan poca experiencia. Sin embargo, un patrón de diseño es tan bueno como el contexto en que se utiliza. Y en algunos raros casos sí que se puede crear software monolítico con muy buenos resultados. Este tipo de software tiene algunas ventajas. Por ejemplo, a diferencia de una arquitectura de microservicios, y al tener menos partes y servicios que consultar, el rendimiento puede ser superior. También tienden a ser más fáciles de depurar y probar porque todo está centralizado en el mismo lugar y, al ser autocontenido, se elimina la posibilidad de errores externos. En muchos círculos, el patrón monolítico de este tipo de arquitectura se considera un antipatrón. Y, personalmente, no te recomiendo usarlo, pero me gusta mencionarlo para que puedas hacer una comparación con el resto de los patrones de diseño.<br/><br/>

* **Arquitectura de microservicios**: Si una aplicación monolítica concentra toda la funcionalidad en un solo punto, los microservicios son todo lo opuesto, distribuyendo los procesos en múltiples partes más pequeñas e independientes. Como todos los patrones de diseño, existen muchas formas de implementar el patrón de microservicios en un software; sin embargo, podemos encontrar algunos elementos comunes. Posiblemente, la característica más común en este patrón de diseño es la distribución de tareas en bloques separados. Estos bloques se llaman componentes de servicios y agrupan uno o varios componentes enfocados en realizar una tarea o un área de negocio de la aplicación. Estos componentes de servicio están completamente desacoplados entre sí y funcionan de forma completamente independiente, lo que permite que cualquiera de ellos pueda ser reemplazado en tiempo real sin afectar el resto de la aplicación. Aunque no es un requisito obligatorio para implementar este patrón, es muy común que la interacción con las bases de datos también esté desacoplada y se realice a través de APIs REST. Esto le permite a los arquitectos crear puntos de entrada y salida de datos que pueden a su vez estar encapsulados en sus propios componentes de servicio, creando APIs consistentes, y a la vez flexibles, que pueden interactuar con diferentes bases de datos. Aplicando esta arquitectura a un ejemplo realista, imaginemos que tenemos un software que administra un centro médico. En este software, tenemos varias áreas de negocio, como un calendario para agendar sesiones médicas, otra con la información de los pacientes y una más que gestiona la parte financiera de este centro médico. Podemos tomar cada área de negocio y convertirla en un componente de servicio. En este caso, por ejemplo, agrupamos los procesos relacionados con la agenda de los médicos en un solo servicio que gestiona todo el proceso. La información de esta agenda se envía a través de una API que provee una interfaz consistente y estable. Esta API, a su vez, modifica la información en la base de datos y muestra los resultados. Esto sería, en su forma más simplificada, el microservicio de agenda médica, y podemos usar el mismo patrón para crear microservicios similares para la información de pacientes o el área financiera, cada uno trabajando por separado, completamente encapsulado. Si un día se necesita cambiar toda la lógica y la base de datos que gestiona a los pacientes, el resto del software sigue funcionando sin problema. La arquitectura de microservicios es muy popular por muchas razones, entre ellas, que es muy fácil de mantener y escalar. Cada vez que la aplicación necesita un área de negocio, se agrega un nuevo componente de servicio. Al estar separada en partes funcionales, una aplicación basada en microservicios es particularmente amigable con las pruebas de integración o end-to-end, lo que ayuda a que se pueda reducir fácilmente la cantidad de errores y regresiones. Esta granularidad también funciona bien para el desarrollo con equipos ágiles, que pueden enfocarse en componentes de servicio específicos y entregar mejoras en ciclos cortos. Por otro lado, la arquitectura basada en microservicios, en ocasiones, presenta problemas de rendimiento. Al manejar partes totalmente independientes, tiene que dedicar recursos a cada una de ellas. También, al depender de APIs externas, puede tener problemas de latencia si la conexión del usuario es lenta, aumentando innecesariamente los tiempos de espera y hasta generando errores de sincronización.<br/><br/>
  
* **Arquitectura de microkernels**: El patrón microkernel, también conocido como arquitectura de plug-ins, es muy popular para aplicaciones que necesitan utilizar software de terceros o agregar rápidamente funcionalidades adicionales. En este patrón de diseño de arquitectura, los componentes se dividen claramente en dos tipos. El primero y más importante es el núcleo central donde se encuentran todas las funciones críticas de la aplicación. El núcleo central de este tipo de aplicaciones es completamente independiente y funcional, no requiere de ningún otro elemento para trabajar. Sin embargo, su funcionalidad se restringe únicamente a los procesos básicos como gestión de hardware, interfaz gráfica o paquetes de uso común. Por otro lado, tenemos a los plug-ins, que funcionan como un componente para el núcleo de la aplicación. Los plug-ins son módulos autocontenidos con una funcionalidad especializada y dependen del entorno que provee el núcleo central para extender su funcionalidad. Este patrón tiene un uso muy extendido y es muy similar al que tiene tu sistema operativo. Cuando instalas, por ejemplo, Windows en tu ordenador, este se encarga de administrar el hardware y ofrece un entorno para poder interactuar con el equipo. Pero por sí mismo, Windows no realiza ninguna tarea en particular. Si quieres, por ejemplo, navegar por internet, tienes que descargar un programa. Este programa depende del entorno y herramientas que crea el sistema operativo para poder funcionar. Por eso es que muchos programas tienen versión para Windows y para Mac, porque cada una de ellas depende de diferentes entornos para trabajar. La arquitectura de microkernels funciona igual. Una vez instalado el núcleo central, tenemos todo lo necesario para comenzar a trabajar, mientras que los plug-ins se pueden instalar para extender o modificar sus capacidades. Usualmente, el núcleo central ofrece algún tipo de API, una serie de rutinas o comandos expuestos de uso común que cualquier plug-in registrado en el sistema puede utilizar para comunicarse con el núcleo, acceder a recursos o desplegar nuevas funcionalidades. Por su parte, los plug-ins son módulos que deben tener toda su funcionalidad autocontenida y totalmente separada del núcleo central. Si el plug-in necesita crear archivos dentro de la aplicación, se debe utilizar un área propia de trabajo o «sandbox» para gestionar sus datos o archivos en un entorno seguro y encapsulado, donde no pueda afectar a otros plug-ins o al sistema principal. En este tipo de arquitectura es importante que, aunque se creen APIs o «sandboxes» para un plug-in, se mantenga totalmente desacoplado del núcleo central para evitar problemas de dependencias. En un escenario ideal, todo plug-in debería poder ser instalado o desinstalado en cualquier momento sin afectar el funcionamiento regular del sistema. Entre las ventajas que ofrece este patrón de arquitectura está su enorme flexibilidad. Una vez que se tiene el núcleo central, es extremadamente fácil agregar o retirar funciones sin preocuparse por posibles regresiones o colapsar el sistema. Esto es particularmente útil cuando se desarrolla software con necesidades que pueden cambiar muy rápido o cuando empresas externas a la organización deben agregar nuevas funcionalidades. Por lo general, las aplicaciones basadas en microkernel son fáciles de probar, lo que reduce drásticamente el índice de errores y regresiones, haciéndolas muy estables y confiables. Por esta razón, son muy populares para el desarrollo de aplicaciones críticas como hospitales o centrales eléctricas. Por otro lado, uno de sus puntos débiles es que al estar todo centralizado en un núcleo principal, no son fáciles de escalar para uso masivo. El desarrollo de este tipo de aplicaciones también requiere de un gran esfuerzo técnico. Primero, porque el núcleo central requiere ser particularmente estable. En muchos casos, necesita administrar entornos muy complejos, o proveer de extensas librerías comunes. Y segundo, porque necesita la creación de una API consistente y un sistema robusto y encapsulado para que los plug-ins puedan funcionar adecuadamente.<br/><br/>
  
* **Arquitectura en capas múltiples**: La arquitectura en capas múltiples es uno de los patrones de diseño de arquitectura más conocidos, y posiblemente sea uno de los más utilizados en proyectos de software, tanto para escritorio como para web. Buena parte de su popularidad se le atribuye a que es la arquitectura por defecto usada en los proyectos basados en Java, uno de los lenguajes de programación más utilizados en la industria de software. Aunque actualmente podemos encontrarlo aplicado prácticamente a cualquier tipo de aplicación y lenguaje de programación. También llamada «arquitectura multicapas», este patrón de diseño, como su nombre lo indica, se basa en la separación de los procesos en unidades llamadas «capas». Una capa es una unidad conceptual ilógica que cumple un rol específico dentro de la aplicación. Por ejemplo, podemos tener una capa dedicada únicamente a la lógica de presentación. En esta capa estaría única y exclusivamente todo lo relacionado con la parte visual de la aplicación. Cualquier otra cosa que no se relacione con esta unidad lógica, debe ir en otra capa. Existen muchas implementaciones de esta arquitectura con diferentes cantidad de capas según las necesidades y características del proyecto, pero no hay un número específico de capas. Al existir variantes de implementación con dos, tres o más capas, es común referirse a este patrón de diseño como arquitectura de N capas para agrupar de forma general todas sus posibles versiones. A pesar de las muchas versiones, a manera de descripción general en una aplicación con una arquitectura de capas, podemos encontrar tres capas frecuentes. La primera, es la capa de presentación. Aquí se incluyen todas las partes de la aplicación relacionadas con la presentación visual, la interacción y el despliegue de información al usuario. Aquí podemos encontrar frameworks de front-end, interfaces gráficas y aplicaciones móviles. La segunda, es la capa de negocio, también llamada «middle-tier», o capa intermedia. Es la encargada de realizar las tareas, cálculos y procesos que requiere la capa de presentación. De este lado encontramos código de programación en diferentes lenguajes o servicios en la nube como Lambdas. La tercera, es la capa de datos, donde se almacena la información que producen los procesos de la aplicación y se despachan datos actualizados para desplegar. Aquí es donde trabajan las bases de datos del sistema. Una aplicación puede trabajar dos, tres, cuatro, o más capas según el tipo de arquitectura y funcionalidad. Si fuera necesario, es posible crear más capas para manejar más granularidad. Lo importante para aplicar correctamente una arquitectura multicapas, no es tanto la cantidad de capas, sino el flujo de la comunicación entre ellas. Cada capa debe ser un entorno separado que puede interactuar únicamente con las capas próximas y jamás saltarse una capa para interactuar con otra. Pensemos en una aplicación multicapa como un pastel, con muchas capas de colores unidas por merengue. Si cortas un trozo, verás que cada una de ellas está en contacto con a capa superior y la inferior, pero no tienen ninguna relación con las capas más inferiores o superiores. Si la capa más alta tiene contacto con la más baja, colapsa el pastel. Lo mismo ocurre con el software; la capa de presentación solo interactúa con la capa de negocio. La capa de negocio solo interactúa con la capa de datos, eso significa que, en este ejemplo, la capa de presentación no tiene forma de acceder directamente a la base de datos. Un ejemplo muy común de una implementación de arquitectura multicapas usando tres capas es el stack MEAN o MERN. El MERN es un acrónimo de las tecnologías usadas para crear una aplicación. En este caso sería, M por MongoDB, un tipo de base de datos no relacional; E por Express, un framemork de back-end; R por React, una librería de JavaScript para gestionar aplicaciones web; y N por Node.js, un servidor también basado en JavaScript. En un sitio así, la separación por capas sería: la capa de presentación es React, gestionando la interfaz de usuario. La capa de negocio o middle-tier, la puede manejar Express a través de una API RESTful en Node. Y finalmente, la capa de datos, le toca a MongoDB. En una aplicación así, los datos que produce React en la capa de presentación se transportan a la API REST de la capa de negocio. y se almacenan en MongoDB en la capa de datos. React, no puede acceder directamente los datos de MongoDB y este a su vez no tiene conocimiento de React, creando así un sistema claro de capas lógicas aisladas entre sí. Las ventajas de este patrón es que al mantener capas tan separadas se vuelve relativamente fácil realizar pruebas unitarias y se reduce la aparición de errores al evitar que un problema en una capa pueda afectar a las demás. Es muy fácil de desarrollar y tiene una baja complejidad porque la mayoría de los programadores tiene familiaridad con sus conceptos. Sin embargo, tiende a tener algunos problemas en condiciones que requieren muy alto rendimiento, y su estructura compleja a veces es difícil de escalar en la nube.<br/><br/>
  
* **Arquitectura basada en espacio**: La arquitectura basada en espacio o SBA, por sus siglas en inglés de «Space Based Architecture», nace de la mano de la popularidad de los servicios en la nube, al punto que también se le conoce como el patrón de arquitectura en la nube. Con la llegada de las aplicaciones web, el avance de las redes sociales y el comercio electrónico, el software que se distribuye por internet ha llegado a tener cifras de tráfico insospechadas. Solo para darte una perspectiva de lo intensivas que son las aplicaciones web, para el año 2000, la totalidad de personas con acceso a internet era de aproximadamente 361 millones. Este era el universo completo de la internet a principios de siglo. Veinte años después, la red social Facebook tiene un tráfico de aproximadamente 1620 millones de usuarios por día. En otras palabras, los servidores de un solo sitio web tienen que lidiar cada día con cinco veces más usuarios que toda la internet combinada del año 2000. A una escala tan grande, hasta el más mínimo detalle cuenta. Y lo que antes eran temas deseables de rendimiento, como la velocidad de carga, la latencia o que el servicio no esté disponible por solo unos pocos segundos, tienen un impacto enorme que puede significar pérdidas millonarias. Y justamente ese es el enfoque de la arquitectura SBA, ayudar a mejorar el rendimiento y escalar operaciones para soportar tráfico masivo. Una aplicación basada en este tipo de arquitectura, utiliza como elemento fundamental aplicaciones autocontenidas llamadas unidades de proceso. Generalmente una unidad de proceso se compone de tres grandes partes: los módulos, que realizan las tareas y procesos de la aplicación; luego un «data grid», que gestiona todas las operaciones de datos en memoria, para aumentar al máximo la velocidad. Y finalmente, el motor de replicado de datos que, en pocas palabras, es quien se encarga de sincronizar los datos de todas las unidades de proceso. Para dar un ejemplo simple de cómo se aplicaría este patrón a un software web, pensemos que estamos creando una tienda en línea. Los módulos, para esta aplicación, serían los que se encargan de todo el proceso de gestión de usuario, inventario o carrito de compra. Todos están agrupados para trabajar en equipo y realizar el flujo completo para que un usuario pueda hacer una compra. Todos ellos forman una unidad de proceso que se puede publicar en la nube. La información de la compra, los artículos seleccionados y los datos de despacho son gestionados dentro de esta unidad de proceso, que puede mantener algún tipo de base de datos local gestionada en la memoria del sistema, mientras el usuario realiza su compra. Los datos de todos los procesos que realiza esta unidad se envían al motor de replicado de datos, que toma, por ejemplo, la información de la compra que acabamos de hacer y la envía al «data grid» de la aplicación, donde se centraliza toda la información. Allí también puedes recoger nuevos datos, por ejemplo, con la lista actualizada de productos de la tienda. El objetivo de que cada unidad de proceso sea independiente y tenga capacidad de sincronizar sus datos a través de procesos paralelos en un punto centralizado, es lo que permite que, dado el caso, si se experimenta un aumento de tráfico, se pueda crear un duplicado de la unidad de proceso y aumentar al doble la capacidad, por ejemplo. Esta es una solución totalmente escalable. Conforme aumenta el tráfico, técnicamente se pueden crear infinitas unidades para atender la demanda. Si baja el tráfico, también se pueden eliminar unidades para reducir el costo de la infraestructura. Las principales ventajas de la arquitectura SBA es que se adapta muy bien a las necesidades de las aplicaciones web, porque permite escalar operaciones para manejar grandes cantidades de tráfico o uso de recursos, algo que agradece cualquier arquitecto que ha vivido la experiencia de que su aplicación se vuelva viral. Su rendimiento es particularmente bueno porque reduce al mínimo la latencia, mientras optimiza el uso de recursos para la gestión de datos. Por otro lado, la principal desventaja de este tipo de arquitectura es que requiere de habilidades técnicas muy avanzadas para la gestión y control de datos. Un error de sincronización puede crear un efecto en cascada que le muestre datos incorrectos o desactualizados a todos o una parte de los usuarios.<br/><br/>
  
* **Arquitectura dirigida por eventos**: Aunque el concepto de evento existe desde los inicios de la computación, este patrón de diseño de arquitectura es relativamente reciente y aparece luego de que la Internet, las tecnologías en la nube y la Internet de las cosas comienzan a consolidarse y crean escenarios totalmente nuevos para el flujo y proceso de datos. Antes de entrar en detalle sobre las características de la arquitectura dirigida por eventos, o EDA, por sus siglas en inglés de «Event Driven Architecture», es necesario que definamos bien qué es un evento. En pocas palabras, un evento es el resultado de una acción o proceso. Hacer clic en el ratón del ordenador, o presionar un botón en pantalla, son ejemplos de un evento. Existen muchísimos tipos de eventos y todos ellos buscan capturar información detallada de una situación. Por ejemplo, si presionas una tecla en tu ordenador, se activa un evento, pero también hay otro evento que detecta cuándo sueltas esa tecla o cuándo la dejas presionada. Cada evento activará una conducta distinta en el ordenador. En el mundo moderno, tenemos infinidad de eventos. Por ejemplo, imagina una expendedora inteligente de bebidas. Un dispositivo como este tiene la capacidad de conectarse a Internet y podemos saber cuánto inventario tiene, cuánto dinero ha recolectado y la temperatura del producto. Este aparato puede enviar información cuando ocurran distintos eventos. Por ejemplo, si se vende una bebida, si la temperatura del producto se sale del rango óptimo o si ya no caben más monedas o billetes y no se pueden realizar más ventas. Hablemos ahora de la diferencia entre una petición y un evento. Una petición es cuando solicitamos un dato. Por ejemplo, cuando entras a tu página favorita de noticias, allí solicitas la más reciente copia de la página o las noticias más frescas. Pero ¿qué pasa si dejas abierto tu navegador hasta el día siguiente? Tendrás las mismas noticias de ayer, que ahora ya están desactualizadas. La única forma de tener las últimas noticias es haciendo otra petición, o sea, refrescando el navegador para pedirle al servidor la copia más reciente de las noticias. La información, en este caso, se procesa solo cuando la solicitas a través de una petición. Un evento, por otro lado, es cuando recibes notificaciones de mensajes de tus amigos por WhatsApp. Tú no le preguntaste a WhatsApp qué decían tus amigos, ni siquiera abriste la aplicación. La notificación llega sola y lo que la activa es el evento de que tu amigo está enviando un mensaje. Aquí la información se procesa cuando se crea, y eso cambia todo. Volvamos al ejemplo del dispensador de bebidas. Si no podemos saber cuántas bebidas quedan, o si están a la temperatura correcta, hasta que alguien pase a revisar el equipo, el proceso es ineficiente; mientras que si el dispositivo puede enviar un evento cuando se queda sin bebidas, o no puede realizar más ventas, y este evento se procesa de inmediato notificando a un técnico para que solucione el problema, se pueden aumentar dramáticamente las ventas. Esto es lo que nos permite la arquitectura dirigida por eventos, crear sistemas altamente eficientes y autónomos que pueden recibir y procesar información en tiempo real. Este tipo de arquitectura es bastante compleja y tiene varias implementaciones y tipologías pero, de forma general, su funcionamiento es el siguiente. Comenzamos con un evento que puede ser cualquier cosa, desde presionar el botón de comprar hasta un sensor meteorológico que detecta que comenzó a llover. El evento pasa a un mediador que es la estructura que recibe el evento, lo ingresa al sistema y comienza el flujo de la tarea. El mediador, activado por el evento, envía sus datos a una unidad especializada llamada procesador de eventos. Un procesador de eventos es un conjunto de módulos que, como su nombre lo sugiere, procesan los datos del evento y generarán las acciones correspondientes. Imaginemos el flujo de datos de esta arquitectura en un ejemplo. Supongamos que tenemos un software médico que monitorea los signos vitales de un paciente y genera gráficos de esa información para el doctor. El paciente tiene un sensor inteligente conectado al sistema que toma 10 diferentes mediciones de datos por cada latido del corazón, y después de una hora ha producido más de 420.000 mediciones. Con una arquitectura dirigida por eventos, no es necesario que un técnico descargue el casi medio millón de mediciones. El sensor está programado para que cada latido del corazón sea un evento y cada uno de ellos envía datos en tiempo real a un punto de entrada del sistema, que sería el mediador del evento. Este mediador se activa cada vez que recibe información y la envía a un componente procesador que contiene una serie de módulos que analizan la información, la almacenan en una base de datos y actualizan los gráficos de signos vitales del paciente. Cuando el doctor llega a ver al paciente, abre su terminal conectada a la base de datos y ya tiene actualizada y procesada la información en un gráfico para evaluar al paciente; incluso puede ver en tiempo real sus signos vitales actualizados. La arquitectura dirigida por eventos se destaca por tener un muy buen rendimiento con excelentes capacidades de escalabilidad en la nube. Por otro lado, su lado negativo es que puede llegar a ser un sistema muy complejo que maneje grandes cantidades de eventos, lo que hace que sea difícil de probar en escenarios realistas con sistemas de pruebas automatizadas. El software que se produce con este tipo arquitectura es difícil de desarrollar y necesita bastante pericia y conocimiento técnico.<br/><br/>
  
* **Modelo Vista Controlador**: Modelo-vista-controlador o MVC, por sus siglas en inglés de «model-view-controller», es un patrón de diseño de software que puede utilizarse como patrón de arquitectura para una aplicación completa. Este patrón tiene sus raíces en la industria del videojuego, donde usualmente se crean aplicaciones con una extensa interacción del usuario y en la que el manejo de datos es vital para gestionar no solo el puntaje sino la ubicación de los elementos en pantalla, el avance del juego y las tablas de puntaje de otros usuarios, entre otros muchos elementos. El modelo-vista-controlador tiene la particularidad de ser un patrón que no funciona para todo tipo de software. Únicamente puede aplicarse en programas donde exista una interfaz gráfica y el usuario pueda de alguna forma interactuar con ella. Como su nombre lo indica, se compone de tres áreas claramente separadas: el modelo, la vista y el controlador. El modelo se refiere a los datos de la aplicación. Aquí es donde se almacenan y procesan absolutamente todos los datos de la aplicación. Este es el cerebro centralizado del software y, si estuviéramos creando un juego con este patrón, aquí debería estar cada dato del juego: la posición de los enemigos, su nivel de vida, la cantidad de disparos, los puntos, el tiempo faltante, el nivel en que se ejecuta el juego. En este patrón, el modelo es la única fuente de información. El resto de la aplicación no posee datos, solo puede reflejarlos. La vista es la interfaz gráfica y todo lo que da la cara al usuario. La vista existe únicamente para desplegar la información que viene del modelo. Si nuestro software es una página web, la vista sería lo que aparece en pantalla. Allí se mostraría el nombre de usuario, la hora o los servicios disponibles en este momento. Si fuera un juego, la vista tomaría los datos del modelo para saber dónde ubicar a los enemigos y el puntaje o el tamaño que debe tener la barra de vida del usuario. Finalmente, está el controlador, que es la parte que se encarga de gestionar la interacción con el usuario. Esto lo hace usualmente a través de eventos como presionar una tecla o mover el «mouse» del ordenador. El controlador detecta estos eventos y los enlaza a procesos que actualizan el modelo. Por ejemplo, al presionar el botón de comprar, envía una notificación al modelo para que se sumen 10 € al monto de tu compra. O en el caso de un juego, cuando presionas una tecla, activa un disparo, indicando al modelo que reduzca un disparo de tu lista de municiones. Y, si ese disparo hace colisión con otro objeto que está clasificado como un enemigo, activa otra notificación al modelo para sumar unidades al puntaje. Cuando el controlador actualiza el modelo, este a su vez actualiza la vista, manteniendo un flujo constante de datos. El modelo-vista-controlador tiene varias ventajas. Su punto más fuerte es que permite desarrollar rápidamente y, gracias a su separación, diferentes equipos pueden trabajar en paralelo sin afectarse mutuamente. Su separación también hace relativamente fácil la ejecución de pruebas, lo que disminuye el índice de errores y regresiones. Por otro lado, su limitación para aplicaciones con interfaz gráfica elimina las posibilidades de uso en entornos exclusivos para el servidor o terminal. También tiene problemas para escalarse tanto a nivel de infraestructura como a nivel de código, haciendo que las aplicaciones complejas y extensas que involucren diferentes lenguajes y plataformas se vuelvan muy difíciles de integrar.<br/><br/>

### Antipatrones de diseño
Los patrones de diseño nos permiten crear un marco común de reglas y lineamientos generales de desarrollo, mejoran la velocidad del trabajo y hasta previenen posibles errores antes de que ocurran. Pero todo esto viene con un precio. Debes apegarte al patrón y seguir sus reglas. De lo contrario, comenzarás a cambiar las cosas, introducir tus propias reglas y eventualmente terminarás con algo totalmente distinto. Así es como nacen los antipatrones que, al igual que los patrones de diseño, son soluciones comunes para un problema. Pero en este caso, el resultado arroja consecuencias negativas. Los antipatrones aparecen generalmente cuando los arquitectos no tienen suficiente conocimiento o experiencia resolviendo un problema, cuando desconocen el concepto de patrones de diseño o cuando comienzan a aplicar correctamente un patrón de diseño pero se implementa mal o se usa en el contexto incorrecto. En muchos casos, un patrón de diseño perfectamente válido puede evolucionar a un antipatrón. Esto ocurre por varios motivos, como cambios en los lenguajes de programación o en los paradigmas dominantes. Por ejemplo, en los años 60 y 70, la programación procedural era un patrón de diseño totalmente aceptado y hasta recomendado. Hoy en día, es casi imposible encontrar una aplicación profesional que se base en programación procedural y en las universidades se enseña como un antipatrón. Al momento de crear este curso, la programación orientada a objetos es un patrón extremadamente común, pero comienza a envejecer y muchos desarrolladores comienzan a cuestionarse si debemos seguir trabajando así o decantarnos por otras opciones, como la programación funcional. Uno de los antipatrones más comunes es el llamado la **navaja suiza**. Cuando se intentan crear estructuras, como por ejemplo una interfaz de clase, extremadamente complejas, tratando de abarcar todos los usos posibles y el resultado es una estructura extremadamente rígida. Este patrón crea estructuras frágiles, porque se centralizan demasiadas tareas en el mismo lugar. Si una pequeña parte falla, es fácil que caiga todo el sistema. También está el diseño por comité, cuando hay demasiadas personas con intereses distintos involucradas en el proceso de diseño. Esto produce una arquitectura extremadamente compleja con poca o ninguna coherencia. Este tipo de arquitectura termina muy comprometida por agradar intereses distintos, sobrecomplicando elementos cruciales, ignorando los temas menos populares como la seguridad y muchas veces perdiendo el objetivo principal de crear una solución funcional. El **martillo dorado** es otro antipatrón común y le ocurre principalmente a los arquitectos más experimentados. Se trata de que una vez que un patrón da buenos resultados en un par de proyectos, se convierte poco a poco en la única solución posible. Sin importar las necesidades de conectividad, de escalabilidad o recursos de proyecto, los arquitectos siempre usarán su martillo dorado para todos los casos. Este antipatrón hace que soluciones perfectamente válidas y correctas sean utilizadas en el contexto incorrecto, lo que producirá resultados inconsistentes. En algunos casos, tendremos buenos resultados, pero en otros no. Es como tratar de construir una casa, un barco y un cohete con la misma herramienta. No siempre funcionará. Para prevenir esto y la mayoría de antipatrones, la mejor vacuna que un arquitecto puede tomar es investigar constantemente. Existen cientos de patrones y variaciones que pueden ayudarnos, y solo el análisis constante nos puede guiar para encontrar el que mejor se ajuste a cada proyecto.

### Problemas comunes para incorporar patrones
Técnicamente, los patrones de diseño de arquitectura son soluciones probadas para problemas frecuentes. Pero el mundo real no es tan simple como para esperar que con solo pedirle a los demás que se aplique un patrón de arquitectura, tus problemas de desarrollar software desaparezcan mágicamente y por adelantado. Implementar un patrón de diseño es un ejercicio social. Necesitas que muchas personas se pongan de acuerdo para trabajar de la misma forma, y justamente este va a ser el primer problema que te toque resolver. Al presentar un plan dentro de una organización, en particular, cuando es la primera vez que se utiliza un patrón de diseño, probablemente encuentres cierta resistencia al cambio. En casos así, asegúrate de presentar un plan de implementación, así como sesiones de capacitación y mentoría al equipo de trabajo. De esta forma, podrán conocer mejor los pros y contras del escenario en el que van a trabajar. El entorno social también afecta directamente el software, incluso en la elección e implementación del patrón de diseño perfecto para un proyecto. La ley de Conway sobre las organizaciones dice que: «Las organizaciones dedicadas al diseño de sistemas están abocadas a producir diseños que son copias de las estructuras de comunicación de dichas organizaciones». Esto quiere decir que las organizaciones tienden a construir software similar a la forma en que ellos mismos se organizan. Y es común encontrar que una organización donde un puñado de personas tiene la última palabra hasta en la más mínima parte del código, se termine desarrollando un software con características monolíticas. Mientras que en una organización descentralizada y separada en equipos independientes, se adapte muy bien a trabajar con una arquitectura de microservicios. No quiere decir que estas organizaciones solo pueden trabajar así, pero está demostrado que tendrán una tendencia a asimilar mejor un patrón que refleje la forma en que trabaja su organización. Otro tema importante que puede afectar mucho al momento de elegir un patrón de diseño de arquitectura es el contexto. Y por esto, me refiero a las condiciones y recursos del proyecto, el tiempo disponible, la pericia de los desarrolladores y todos los aspectos que afectarán directa o indirectamente el software. Existen centenares de patrones diferentes, y cada uno de ellos se puede modificar ligeramente según el software y la organización que lo trabaja, lo que da como resultado una casi infinita gama de matices. Si no tomamos en cuenta el contexto de nuestro proyecto, sus necesidades, recursos y objetivos, nos arriesgamos a crear una solución que no sea compatible con el proyecto, que requiera demasiado esfuerzo para funcionar como se espera y aunque se elija un buen patrón de diseño, puede terminar siendo un enorme dolor de cabeza. Elegir un patrón de diseño siempre viene con un «trade-off», o sea, una serie de pros y contras que no podemos separar. Puede que, por un lado, te ayuden a escalar más rápido, pero por el otro, afecten tu rendimiento o aumenten radicalmente el rendimiento a cambio de sacrificar la facilidad para programar. Por eso, como arquitecto, debes siempre saber que los patrones de diseño son como los medicamentos, mejoran tu salud, pero todos tienen efectos secundarios.
